(window.webpackJsonp=window.webpackJsonp||[]).push([[144],{309:function(t,e,a){"use strict";a.r(e);var r=a(0),v=Object(r.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"vuex"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vuex","aria-hidden":"true"}},[t._v("#")]),t._v(" Vuex")]),t._v(" "),a("p",[t._v("Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化\n")]),t._v(" "),a("h2",{attrs:{id:"vuex的主要概念"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vuex的主要概念","aria-hidden":"true"}},[t._v("#")]),t._v(" Vuex的主要概念")]),t._v(" "),a("p",[t._v("State:Vuex 使用单一状态树——是的，用一个对象就包含了全部的应用层级状态")]),t._v(" "),a("blockquote",[a("p",[t._v("mapState 辅助函数当一个组件需要获取多个状态时候，将这些状态都声明为计算属性会有些重复和冗余。为了解决这个问题，我们可以使用 mapState 辅助函数帮助我们生成计算属性")])]),t._v(" "),a("p",[t._v("Getter:Vuex 允许我们在 store 中定义“getter”（可以认为是 store 的计算属性）。就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。")]),t._v(" "),a("blockquote",[a("p",[t._v("mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性")])]),t._v(" "),a("p",[t._v("Mutation:更改 Vuex 的 store 中的状态的唯一方法是提交 mutation,每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数")]),t._v(" "),a("p",[t._v("Mutation 需遵守 Vue 的响应规则：\n1.最好提前在你的 store 中初始化好所有所需属性。")]),t._v(" "),a("p",[t._v("2.当需要在对象上添加新属性时，你应该:使用 Vue.set(obj, 'newProp', 123), 或者以新对象替换老对象")]),t._v(" "),a("blockquote",[a("p",[t._v("使用 mapMutations 辅助函数将组件中的 methods 映射为 store.commit 调用")])]),t._v(" "),a("p",[t._v("Action:Action 类似于 mutation，不同在于：\n1.Action 提交的是 mutation，而不是直接变更状态。")]),t._v(" "),a("p",[t._v("2.Action 可以包含任意异步操作")]),t._v(" "),a("blockquote",[a("p",[t._v("使用 mapActions 辅助函数将组件的 methods 映射为 store.dispatch 调用")])]),t._v(" "),a("p",[t._v("Module:Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块")]),t._v(" "),a("h2",{attrs:{id:"vuex流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vuex流程","aria-hidden":"true"}},[t._v("#")]),t._v(" Vuex流程")]),t._v(" "),a("p",[a("img",{attrs:{src:"/img/vuex.png",alt:""}})]),t._v(" "),a("h2",{attrs:{id:"vuex需遵守规则"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vuex需遵守规则","aria-hidden":"true"}},[t._v("#")]),t._v(" Vuex需遵守规则")]),t._v(" "),a("p",[t._v("Vuex 并不限制你的代码结构。但是，它规定了一些需要遵守的规则：")]),t._v(" "),a("p",[t._v("1.应用层级的状态应该集中到单个 store 对象中。")]),t._v(" "),a("p",[t._v("2.提交 mutation 是更改状态的唯一方法，并且这个过程是同步的。")]),t._v(" "),a("p",[t._v("3.异步逻辑都应该封装到 action 里面。")])])}),[],!1,null,null,null);e.default=v.exports}}]);